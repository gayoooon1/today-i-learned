#include <stdio.h>
#include <stdlib.h>

#define MAX_SIZE 100

char visited_path[25][19] =
{
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', 'E', '0'},
	{'0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0', '0'}

};

char maze[25][19] =
{
	{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'},
	{'1', 'S', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '1', '0', '1'},
	{'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1'},
	{'1', '0', '0', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '1', '0', '1'},
	{'1', '1', '1', '1', '1', '0', '1', '0', '1', '0', '1', '1', '1', '0', '1', '0', '1', '0', '1'},
	{'1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1'},
	{'1', '0', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1', '0', '1'},
	{'1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '0', '0', '1', '0', '1'},
	{'1', '0', '1', '0', '1', '1', '1', '0', '1', '0', '1', '1', '1', '0', '1', '1', '1', '0', '1'},
	{'1', '0', '1', '0', '1', '0', '0', '0', '1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1'},
	{'1', '0', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1', '0', '1', '1', '1'},
	{'1', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1', '0', '1'},
	{'1', '0', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1', '1', '1', '0', '1'},
	{'1', '0', '0', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '0', '0', '1'},
	{'1', '1', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1', '1', '0', '1', '0', '1'},
	{'1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '1'},
	{'1', '0', '1', '0', '1', '1', '1', '1', '1', '0', '1', '0', '1', '1', '1', '1', '1', '1', '1'},
	{'1', '0', '1', '0', '0', '0', '0', '0', '0', '0', '1', '0', '0', '0', '0', '0', '0', '0', '1'},
	{'1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '1', '1', '0', '1', '1', '1', '0', '1'},
	{'1', '0', '0', '0', '0', '0', '1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1'},
	{'1', '0', '1', '1', '1', '0', '1', '0', '1', '0', '1', '0', '1', '1', '1', '0', '1', '0', '1'},
	{'1', '0', '0', '0', '1', '0', '1', '0', '1', '0', '1', '0', '0', '0', '0', '0', '1', '0', '1'},
	{'1', '1', '1', '0', '1', '0', '1', '0', '1', '0', '1', '0', '1', '1', '1', '1', '1', '0', '1'},
	{'1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0', '1', '0', '0', '0', '0', 'E', '1'},
	{'1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1', '1'}

};

const unsigned char up = 1;
const unsigned char down = 2;
const unsigned char left = 4;
const unsigned char right = 8;

typedef struct Position
{
	int x;
	int y;

} Position;

typedef struct Stack
{
	Position data[100];
	int top;
} Stack;

void init(Stack* p)
{
	p->top = -1;
}

int is_full(Stack* p)
{
	if (p->top == (MAX_SIZE - 1))
	{
		printf("STACK IS FULL!\n");
		return -1;
	}
	else return 0;
}

int is_empty(Stack* p)
{
	if (p->top == -1)
	{
		printf("STACK IS EMPTY!\n");
		return -1;
	}
	else return 0;
}

void push(Stack* p, Position data)
{
	if (is_full(p) == -1) exit(1);
	else
	{
		p->top++;
		p->data[p->top].x = data.x;
		p->data[p->top].y = data.y;
		printf("PUSH(%d, %d)\n", data.x, data.y);
	}
}

Position pop(Stack* p)
{
	if (is_empty(p) == -1) exit(1);
	else
	{
		return p->data[(p->top)--];
	}
}


void print_maze()
{
	for (int i = 0; i < 25; i++) 
	{
		for (int j = 0; j < 19; j++)
		{
			if (maze[i][j] == 'S' || maze[i][j] == 'E')
			{
				printf(" %c", maze[i][j]);
				continue;
			}
			else if (visited_path[i][j] == 'O')
			{
				printf(" %c", visited_path[i][j]);
				continue;
			}
			else if (maze[i][j] == '0')
			{
				printf("  ");
				continue;
			}
			else (maze[i][j] == '1');
			{
				printf(" +");
				continue;
			}			

		}
	printf("\n");
	}



}
unsigned char map[25][19] = { 0, };

void dir_finder() 
{
	unsigned char pos;
	unsigned char pos_total = 0;
	for (int y = 1; y < 24; y++) //24 세로
	{
		for (int x = 1; x < 18; x++) //18 가로
		{
			if (maze[y][x] == '1')
			{
				map[y][x] = 0;
				continue;
			}
			
			if (maze[y][x + 1] == '0' || maze[y][x + 1] == 'E')
			{
				pos = right;
				pos_total += pos;
				map[y][x] = pos_total;
			}
			if (maze[y][x - 1] == '0' || maze[y][x - 1] == 'S')
			{
				pos = left;
				pos_total += pos;
				map[y][x] = pos_total;
			}
			if (maze[y - 1][x] == '0')
			{
				pos = up;
				pos_total += pos;
				map[y][x] = pos_total;
			}
			if (maze[y + 1][x] == '0')
			{
				pos = down;
				pos_total += pos;
				map[y][x] = pos_total;
			}
			pos_total = 0;
		}
	}
}



int visit_finder(int x, int y)
{
	if (visited_path[y][x] == 'O') return -1;
	else return 1;
}

int dir_compare(int map, int dir)
{
	return (map & dir);
}

int no_way_to_go(int x, int y)
{
	if (map[y][x] == 0) return 1;
	if ((map[y + 1][x] == 0) && (map[y][x + 1] == 0) && (map[y][x - 1] == 0)) return 1;
	if ((map[y + 1][x] == 0) && (map[y - 1][x] == 0) && (map[y][x - 1] == 0)) return 1;
	if ((map[y + 1][x] == 0) && (map[y - 1][x] == 0) && (map[y][x + 1] == 0)) return 1;
	if ((map[y - 1][x] == 0) && (map[y][x + 1] == 0) && (map[y][x - 1] == 0)) return 1;
	if (visit_finder(x - 1, y) == -1) return 1;
	else return 0;
}

int end(int x, int y)
{
	if (visited_path[y][x] == 'E') return 1;
	else return -1;
}


void path_finder()
{
	int visit;
	Stack s;
	Position now;
	Position tmp;
	now.x = 1;
	now.y = 1;
	init(&s);
	while (end(now.x, now.y) != 1)//x가 가로 y가 세로
	{
		visit = visit_finder(now.x, now.y);
		if ((dir_compare(map[now.y][now.x], 2) == 2) && (visit_finder(now.x, now.y + 1) != -1) || (visited_path[now.y + 1][now.x] == 'E')) //down
		{
			if ((dir_compare(map[now.y][now.x], 8) == 8))
			{
				tmp.x = now.x;
				tmp.y = now.y;
				push(&s, tmp);
			}
			else if ((dir_compare(map[now.y][now.x], 4) == 4))
			{
				tmp.x = now.x;
				tmp.y = now.y;
				push(&s, tmp);
			}
			visited_path[now.y][now.x] = 'O';
			now.y = now.y + 1;
			continue;
		}
		if ((dir_compare(map[now.y][now.x], 4) == 4) && (visit_finder(now.x - 1, now.y) != -1)) //left
		{
			visited_path[now.y][now.x] = 'O';
			now.x = now.x - 1;
			continue;
		}
		if ((dir_compare(map[now.y][now.x], 8) == 8) && (visit_finder(now.x + 1, now.y) != -1)) //right
		{
			visited_path[now.y][now.x] = 'O';
			now.x = now.x + 1;
			continue;
		}
		
		if ((dir_compare(map[now.y][now.x], 1) == 1) && (visit_finder(now.x, now.y - 1) != -1)) //up
		{
			visited_path[now.y][now.x] = 'O';
			now.y = now.y - 1;
			continue;
		}
		else if ((visit == -1) || (no_way_to_go(now.x, now.y) == 1))
		{
			now = pop(&s);
			visited_path[now.y][now.x] = '0';
			printf("POP (%d, %d)\n", now.x, now.y);
			continue;
		}


	}
}
int main(void) {

	dir_finder();
	path_finder();
	print_maze();
	printf("길 찾음\n");

	
}